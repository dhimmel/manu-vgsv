## Methods

### Toil-vg

Toil-vg is a set of Python scripts for simplifying vg tasks such as graph construction, read mapping and SV genotyping.  It uses the Toil workflow engine [@tag:toil] to seamlessly run pipelines locally, on clusters or on the cloud.  All variation graph analysis in this report was done using toil-vg, with the exact commands available [here](https://github.com/glennhickey/hgsvc) [todo: get everything in one place with reasonable docs].  The principal toil-vg commands used are described below.

#### Toil-vg construct

Toil-vg construct automates graph construction and indexing following the best practices put forth by the vg community.
Graph construction is parallelized across different sequences from the reference fasta, and different whole-genome indexes are created side by side when possible.
Phasing information from the input VCF can be used when available to preserve haplotypes in the GCSA2 pruning step, as well as to extract haploid sequences to simulate from.

#### Toil-vg map

Toil-vg map splits the input reads into batches, maps each batch in parallel, then merges the result.

#### Toil-vg call

A simple though very general variant caller has been implemented as vg call.
Here it is used to genotype structural variants already present in the graph, but the same algorithm can also be used for smaller variants such as SNPS, as well as making de-novo calls.
The algorithm is as follows:

1. The average read support for each node and edge, adjusted for mapping and base quality, is computed. The graph can optionally be augmented to include new variation from the reads.
2. The graph is then decomposed into snarls.  Briefly, a snarl is a subgraph defined by two end nodes, where cutting the graph at these nodes disconnects the snarl from the rest of the graph.  (todo: work on way to define this without getting into bidrected graphs, or is that a lost cause?). Snarls can be nested inside other snarls, and this nesting hierarchy forms a forest (todo: I don't think chains get used anywhere in vg call so we can ignore here). The snarl decomposition is a fundamental structure for identifying variants in a graph and are formally defined, along with an algorithm to identify them, in [@tag:snarls].
3. Root-level snarls from the decomposition are considered independently and in parallel.  Only snarls whose two ends lie on a reference (ie chromosome) path are considered as the VCF format used for ouptut requires reference positions.  The following steps are performed on each root snarl. 
4. A set of paths between the snarls end nodes are computed. (todo, consult with Adam about writing up the RepresentativeTraversalFinder)
5. The paths are ranked according to their average support.
6. A genotype is determined using the relative support of the best traversals, as well as the background read depth.
7. The VCF variants are derived from the paths.
(todo: expand and clarify these last steps.  could leave them fairly brief here and go into detail in the supplement).


Due to the high memory requirements of the current implementation of vg call, toil-vg call splits the input graph into 2.5Mb overlapping chunks along the reference path.
Each chunk is called independently in parallel and the results are concatenated into the output VCF.   

#### Toil-vg sveval / SVEval

Sveval can almost be its own application note, but needs at least to be described a bit here.  

#### HGSVC Analysis

Phased VCFs were obtained for the three HGSVC samples from the authors of [@tag:hgsvc] and combined with bcftools merge.
A variation graph was created and indexed using the combined VCF and the HS38D1 reference with alt loci excluded.
The phasing information was used to construct a GWBT index, from which the two haploid sequences from HG00514 were extracted.
Illumina read pairs with 30x coverage were simulated from these sequences using vg, with an error model learned from real reads from the same sample.
Still, these reads reflect the idealized situation where the breakpoints of the SVs being genotyped are exactly known a priori.
The reads were mapped to the graph and the mappings used to genotype the SVs in the graph, which were finally compared back to the HG00514 genotypes from the HGSVC VCF.
The process was repeated with the same reads on the linear reference, using bwa-mem for mapping and DELLY, SVTYPER and Bayestyper for SV genotyping.

Illumina HiSeq 2500 paired end reads were downloaded from the EBI's ENA FTP site for the three samples, using Run Accessions ERR903030, ERR895347 and ERR894724 for HG00514, HG00733 and NA19240, respectively.
The graph and linear mapping and genotyping pipelines were run exactly as for the simulation, and the comparison results were aggregated across the three samples.

#### GIAB Analysis

Version 0.6 of the GIAB SV VCF for the Ashkenazim son (HG002) was obtained from the NCBI FTP site.
Illumina reads downsampled to 50x coverage obtained as described in [@tag:vgnbt], were used to run the vg and linear SV genotyping pipelines described above though with GRCh37 instead of 38.
Since this dataset contains only one sample, variants without a determined genotype (14649 out of 74012) were considered "false positives" as a proxy measure for precision.

Todo: I think some more thought may need to go into this comparison.  I'd actually assumed before writing this up that the whole trio was in the VCF but this is not the case -- it's just for the one sample.  The curreny results will count as a false positive a call that was not assigned a genotype by GIAB.  This is probably a pretty good estimate, but I think it's too hand wavy to publish.  In the worst case, we can switch to just looking at recall on the whole set (which has the advantage of being exactly what that other paper did for deletions).

#### SMRT-SV2 Comparison (CHMPD and SVPOP)

The SMRT-SV2 genotyper can only be used to genotype VCFs that were created by SMRT-SV2, and therefore could not be run on our simulated, HGSVC or GIAB data.
The authors shared their training and evaluation set, a pseudodiploid sample constructed from combining the haploid CHM1 and CHM13 samples, along with a negative control (NA19240).  
The high quality of the CHM assemblies makes this set an attractive alternative to using simulated reads.
We used this two-sample pseudodiploid VCF along with the 30X read set to construct, map and genotype with vg, and also ran SMRT-SV2 genotyper with the "30x-4" model and min-call-depth 8 cutoff, and compared the two back to the original VCF.

In an effort to extend this comparison to a more realistic setting, we reran the three HGSVC samples against the SMRT-SV2 discovery VCF (which contains them in addition to 12 other samples) published in [@tag:audano2019] using vg and SMRT-SV2 Genotyper.
The discovery VCF does not contain genotypes so we did not distinguish between heterozygous and homozygous genotypes, looking at only the presence or absence of an alt allele in each variant.


#### Yeast graph analysis

For the analysis of graphs from de novo assemblies, we utilized publically available PacBio-derived assemblies and Illumina short read sequencing datasets for 12 yeast strains from two related clades (S. cerevisiae and S. paradoxus) [@doi:10.1038/ng.3847].
Two different genome graphs were constructed from the assemblies of five selected strains (S.c. S288C, S.c. SK1, S.c. YPS128, S.p. CBS432, S.p.UFRJ50816).
In the following, we describe the steps for the construction of both graphs and the calling of variants.
For more details and the precise commands used in our analyses, see the following Github repository: https://github.com/eldariont/yeast_sv.

#### Construction of the *construct graph*
For the first graph (throughout the paper called *construct graph*) the usual graph construction method was applied that uses a linear reference genome and a VCF file of variants.
As reference genome, the PacBio assembly of the S.c. S288C strain was chosen because it is the strain used for the S. cerevisiae genome reference assembly.
To obtain variants three methods for SV detection from genome assemblies were combined: Assemblytics [@doi:10.1093/bioinformatics/btw369] (commit df5361f809a7034d4ab6acde1691cc962b82d833), AsmVar (commit 5abd91a47feedfbd39b89ec3e2d6d20c02fe5a5e) [@doi:10.1186/s13742-015-0103-4] and paftools (version 2.14-r883) [@doi:10.1093/bioinformatics/bty191].
All three methods were run to detect SVs between the PacBio assembly of reference strain S.c. S288C and the PacBio assemblies of each of the four other selected yeast strains.
The union of variants detected by the three methods was produced and variants with a reciprocal overlap of at least 50% were combined to avoid duplication in the union set.
These union sets of variants for each of the four selected (and non-reference) strains were merged and another deduplication step was applied to combine variants with a reciprocal overlap of at least 90%.
The resulting total set of variants in VCF format and the linear reference genome were used to build the *construct graph* with `vg construct`.

#### Construction of the *cactus graph*
For the second graph (throughout the paper called *cactus graph*) an alternative graph construction methods directly from de novo genome assemblies was applied.
First, the repeat-masked PacBio-assemblies of the five selected strains were aligned with our Cactus tool [@doi:10.1101/gr.123356.111].
Subsequently, the output file in HAL format was converted to a variant graph with hal2vg (https://github.com/ComparativeGenomicsToolkit/hal2vg).

#### Calling and genotyping of SVs
Prior to variant calling, the Illumina short reads of all 12 yeast strains were mapped to both graphs using `vg map`.
The fractions of reads mapped with specific properties were measured using `vg view` and the JSON processor `jq`.
Then, `toil-vg call` (commit be8b6dadac5372081ae54fad868458656258948e from March 20, 2019) was used to analyze the mapped reads of each of the 11 non-reference strains and to call variants.
Thus, a separate variant callset was obtained for each of the strains and both of the graphs.
To evalute the callsets, a sample graph was generated for each callset using `vg construct` and `vg mod` on the reference assembly S.c. S288C and the callset.
Subsequently, short reads from the respective strains were mapped to each sample graph using `vg map`.
The resulting alignments were analyzed `vg view` and the `jq`.
